#!/usr/bin/env python2.7
#
'''Metric - Performance Metric Calculator

Metric uses predefined formulee to calculate certain performance metrics from a
set of performance counter values. It currently supports the likwid style of
performance group.

To use Metric, feed it a database file generated by 'bentoo-collector', it will
calculate automatically derived formulee defined in likwid perfgroup format.
Note that only raw performance counters shall be stored in the database.
'''

import os
import re
import argparse
import sqlite3


#
# Likwid Helpers
#

class BlockReader(object):

    def __init__(self, start, end, use_regex=False):
        if use_regex:
            self.start_ = re.compile(start)

            def match_start(x):
                return self.start_.match(x)
            self.match_start = match_start

            self.end = re.compile(end)

            def match_end(x):
                return self.end_.match(x)
            self.match_end = match_end
        else:
            def match_start(x):
                return x == self.start_

            def match_end(x):
                return x == self.end_

            self.start_ = start
            self.end_ = end
            self.match_start = match_start
            self.match_end = match_end

    def iterblocks(self, iterable):
        while True:
            try:
                block = []
                while not self.match_start(iterable.next()):
                    continue
                line = iterable.next()
                while not self.match_end(line):
                    block.append(line)
                    line = iterable.next()
                yield block
            except StopIteration:
                return

    def findblock(self, iterable):
        block = []
        while not self.match_start(iterable.next()):
            continue
        line = iterable.next()
        while not self.match_end(line):
            block.append(line)
            line = iterable.next()
        return block


class EventsetParser(object):

    def __init__(self):
        self.events = []
        self.counters = []

    def process(self, iterable):
        for line in iterable:
            counter, event = line.split()
            self.events.append(event)
            self.counters.append(counter)


class MetricsParser(object):

    def __init__(self):
        self.metrics = []

    def process(self, iterable):
        for line in iterable:
            if re.findall(r"\[.*\]", line):
                name, unit, formula = map(lambda x: x.strip(),
                                          re.match(r"^(.*?)\[(.*?)\](.*)$",
                                                   line).groups())
                self.metrics.append((name, unit, formula))
            else:
                name, formula = map(lambda x: x.strip(),
                                    re.match(r"^(.*?)(\S+)$", line).groups())
                self.metrics.append((name, "1", formula))


def stringify(content):
    return re.sub(r"\W", "_", content)


class LikwidMetrics(object):

    def __init__(self, group_file):
        with open(group_file) as groupfile:
            eventset_reader = BlockReader("EVENTSET\n", "\n")
            metrics_reader = BlockReader("METRICS\n", "\n")
            ep = EventsetParser()
            mp = MetricsParser()
            ep.process(eventset_reader.findblock(groupfile))
            mp.process(metrics_reader.findblock(groupfile))
            self.eventset = {"events": ep.events, "counters": ep.counters,
                             "pair": ["%s:%s" % x for x in zip(ep.events,
                                                               ep.counters)]}
            self.metrics = mp.metrics

    def event_count(self):
        return len(self.eventset["events"])

    def event_name(self, event_id):
        return self.eventset["events"][event_id]

    def counter_name(self, event_id):
        return self.eventset["counters"][event_id]

    def event_counter_pair(self, event_id):
        return self.eventset["pair"][event_id]

    def metric_count(self):
        return len(self.metrics)

    def metric_name(self, metric_id):
        return self.metrics[metric_id][0]

    def normal_metric_name(self, metric_id):
        return stringify(self.metrics[metric_id][0])

    def metric_unit(self, metric_id):
        return self.metrics[metric_id][1]

    def calc_metric(self, metric_id, eventvals):
        formula = str(self.metrics[metric_id][2])
        for k, v in eventvals.iteritems():
            formula = formula.replace(k, str(v))
        try:
            result = eval(formula)
        except ZeroDivisionError:
            result = 0.0
        return result


#
# Metric Calculator
#

SQLITE_TYPE = {
    type(None): "NULL",
    int: "INTEGER",
    long: "INTEGER",
    float: "REAL",
    str: "TEXT",
    unicode: "TEXT",
    buffer: "BLOB"
}


def column_split(columns):
    '''split 'columns' into (index_columns, data_columns)'''
    timer_column_index = columns.index("TimerName")
    return (columns[:timer_column_index+1], columns[timer_column_index+1:])


def locate_likwid_group_file(arch, group):
    # NOTE: Here we respect Likwid's group file locating mechanism: first try
    # "~/.likwid/groups/ARCH/GROUP", then "LIKWID_HOME/share/likwid
    # /perfgroups/ARCH/GROUP".
    user_conf_path = os.path.expanduser("~/.likwid/groups")
    group_file = os.path.join(user_conf_path, arch, group + ".txt")
    if os.path.exists(group_file):
        return group_file
    sys_path = os.environ["PATH"].split(":")
    for p in sys_path:
        if os.path.exists(os.path.join(p, "likwid-perfctr")):
            likwid_home = os.path.dirname(os.path.abspath(p))
            group_file = os.path.join(likwid_home, "share", "likwid",
                                      "perfgroups", arch, group + ".txt")
            if not os.path.exists(group_file):
                raise ValueError("Bad likwid installation: can not find "
                                 "'%s' for '%s' in '%s'" % (group, arch,
                                                            likwid_home))
            return group_file
    raise ValueError("Can not find likwid group '%s' for '%s'" % (group, arch))


def calc_likwid_metric(raw_db, output_db, aggregate="no", likwid_group=None,
                       likwid_group_file=None, raw_events=False):
    # determine operation type
    if not raw_events and not likwid_group and not likwid_group_file:
        raise ValueError("Incorrect operation selection")

    conn0 = sqlite3.connect(raw_db)
    conn0.row_factory = sqlite3.Row

    # Discover the structure of input database
    sql = "select * from result limit 1"
    r0 = conn0.execute(sql).fetchone()
    input_columns = r0.keys()
    index_columns, data_columns = column_split(input_columns)

    sql = "select * from result where "
    sql += "TimerName glob \"CPU_CYCLES@*\" limit 1"
    r0 = conn0.execute(sql).fetchone()
    cpu_cycles_timer_name = r0["TimerName"]
    cpu_cycles = r0["RDTSC"]
    cpu_model = cpu_cycles_timer_name.split("@")[-1]

    if not raw_events:
        if likwid_group_file:
            likwid = LikwidMetrics(likwid_group_file)
        elif likwid_group:
            # find out correct group file
            group_file = locate_likwid_group_file(cpu_model, likwid_group)
            likwid = LikwidMetrics(group_file)

    def quote(x):
        return "\"{}\"".format(x)

    select = []
    group_by = []
    if aggregate == "no":
        group_by = map(quote, index_columns)
        select = map(quote, input_columns)
    elif aggregate == "thread":
        new_index_columns = list(index_columns)
        new_index_columns.remove("ThreadId")
        group_by = map(quote, new_index_columns)
        select.extend(group_by)
        select.append("COUNT(ThreadId) AS ThreadCount")
        for k in data_columns:
            if k == "RDTSC":
                select.append("SUM(RDTSC) AS SumRDTSC")
                select.append("MAX(RDTSC) AS MaxRDTSC")
            elif k == "CallCount":
                select.append("SUM(CallCount) AS SumCallCount")
            else:
                select.append("SUM(\"{0}\") AS \"{0}\"".format(k))
    else:
        new_index_columns = list(index_columns)
        new_index_columns.remove("ThreadId")
        new_index_columns.remove("ProcId")
        group_by = map(quote, new_index_columns)
        select.extend(group_by)
        select.append("COUNT(ProcId) AS ProcCount")
        select.append("COUNT(ThreadId) AS ThreadCount")
        for k in data_columns:
            if k == "RDTSC":
                select.append("SUM(RDTSC) AS SumRDTSC")
                select.append("MAX(RDTSC) AS MaxRDTSC")
            elif k == "CallCount":
                select.append("SUM(CallCount) AS SumCallCount")
            else:
                select.append("SUM(\"{0}\") AS \"{0}\"".format(k))

    select = ", ".join(select)
    where = "TimerName != \"%s\"" % cpu_cycles_timer_name
    group_by = ", ".join(group_by)
    select_sql = "SELECT {0} FROM result WHERE {1} GROUP BY {2}".format(
        select, where, group_by)

    def is_event_column(c):
        return re.match(r"[_A-Z0-9]+:[_A-Z0-9]+", c)

    # create result sqlite database
    c0 = conn0.cursor()
    r0 = c0.execute(select_sql)
    r0 = c0.fetchone()
    if raw_events:
        output_columns = list(r0.keys())
        output_types = [type(r0[k]) for k in output_columns]
    else:
        output_keys = r0.keys()
        output_columns = [c for c in output_keys if not is_event_column(c)]
        output_types = [type(r0[c]) for c in output_columns]
        for i in xrange(likwid.metric_count()):
            output_columns.append(likwid.normal_metric_name(i))
            output_types.append(float)

    conn1 = sqlite3.connect(output_db)
    conn1.execute("DROP TABLE IF EXISTS result")
    type_pairs = zip(output_columns, output_types)
    sql = ["\"{0}\" {1}".format(k, SQLITE_TYPE[v]) for k, v in type_pairs]
    sql = "CREATE TABLE result (%s)" % ", ".join(sql)
    conn1.execute(sql)

    def compute_metrics(r0):
        if raw_events:
            return list(r0)
        event_values = dict()
        result = []
        for k, v in zip(r0.keys(), r0):
            if is_event_column(k):
                counter_name = k.split(":")[-1]
                event_values[counter_name] = v
            else:
                result.append(v)
        if aggregate != "no":
            event_values["time"] = r0["MaxRDTSC"]
        else:
            event_values["time"] = r0["RDTSC"]
        event_values["inverseClock"] = 1.0 / cpu_cycles
        for i in xrange(likwid.metric_count()):
            result.append(likwid.calc_metric(i, event_values))
        return result

    metrics = compute_metrics(r0)
    ph_sql = ", ".join(["?"] * len(metrics))
    insert_row_sql = "INSERT INTO result VALUES ({0})".format(ph_sql)
    conn1.execute(insert_row_sql, metrics)
    for r0 in c0.fetchall():
        metrics = compute_metrics(r0)
        ph_sql = ", ".join(["?"] * len(metrics))
        insert_row_sql = "INSERT INTO result VALUES ({0})".format(ph_sql)
        conn1.execute(insert_row_sql, metrics)

    conn1.commit()
    conn1.close()
    conn0.close()


def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("raw_db",
                        help="Database containing raw event values")
    parser.add_argument("output_db",
                        help="Database to store calculated metrics")
    parser.add_argument("--aggregate", default="thread",
                        choices=["no", "thread", "proc_thread"],
                        help="Data aggregation (default: thread)")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--likwid-group", default=None,
                       help="Likwid perfgroup name")
    group.add_argument("--likwid-group-file", default=None,
                       help="Likwid perfgroup file")
    group.add_argument("--raw-events", action="store_true",
                       help="Compute raw events instead of metrics")

    args = parser.parse_args()
    calc_likwid_metric(**vars(args))


if __name__ == "__main__":
    main()
