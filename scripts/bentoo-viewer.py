#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
'''
bentoo-viewer.py - view bentoo-calltree-analyser results graphically

This tool visualizes datasets generated by bentoo-calltree-analyser.
'''

import os
import sqlite3
import argparse
import numpy
import pandas
import json
import re
import toyplot
import toyplot.color
import toyplot.svg
import toyplot.pdf
import toyplot.png
import toyplot.browser

#
# data reader
#

import collections

try:
    import yaml

    def dict_representer(dumper, data):
        return dumper.represent_dict(data.iteritems())

    def dict_constructor(loader, node):
        return collections.OrderedDict(loader.construct_pairs(node))

    yaml.add_representer(collections.OrderedDict, dict_representer)
    yaml.add_constructor(yaml.resolver.BaseResolver.DEFAULT_MAPPING_TAG,
                         dict_constructor)

    def loads(string, *args, **kwargs):
        return yaml.load(string, *args, **kwargs)

except ImportError:
    import json

    def loads(string, *args, **kwargs):
        return json.loads(
            string, object_pairs_hook=collections.OrderedDict, *args, **kwargs)

#
# Auxiliary functions
#


def draw_line(axes, x0, y0, x1, y1, *args, **kwargs):
    axes.plot([x0, x1], [y0, y1], *args, **kwargs)


def draw_points(axes, data, *args, **kwargs):
    x = [c[0][0] for c in data]
    y = [c[0][1] for c in data]
    color = [c[1] for c in data]
    axes.scatterplot(x, y, color=color, *args, **kwargs)

#
# Layout algorithm for tree representation
#


class UniqueId(object):
    def __init__(self, start=0):
        self.value = start

    def id(self):
        self.value += 1
        return self.value - 1


def build_tree(data):
    def flat_to_recursive(nodes):
        if not nodes:
            return []
        result = []
        min_level = min(x[0] for x in nodes)
        assert (nodes[0][0] == min_level)
        nid, children = (nodes[0][1], [])
        for l, n in nodes[1:]:
            if l == min_level:
                result.append({"id": nid,
                               "children": flat_to_recursive(children)})
                nid, children = (n, [])
            else:
                children.append((l, n))
        result.append({"id": nid, "children": flat_to_recursive(children)})
        return result

    nodes = [(data["level"][i], data["id"][i])
             for i in xrange(len(data["id"]))]
    trees = flat_to_recursive(nodes)
    assert (len(trees) == 1)
    return trees[0]


def compute_layout(data, colors):
    tree = build_tree(data)

    # id -> (level, name)
    rows = {}
    rowids = {}
    uuid = UniqueId()

    def compute_rows(tree, level=0):
        if not tree:
            return
        node_id = uuid.id()
        rows[node_id] = (level, tree["id"])
        rowids[tree["id"]] = node_id
        for c in tree["children"]:
            compute_rows(c, level + 1)

    compute_rows(tree)

    lines = []

    def compute_lines(tree, level=0):
        if not tree:
            return
        children = []
        for c in tree["children"]:
            children.append(rowids[c["id"]])
        if not children:
            return
        start_row = rowids[tree["id"]]
        end_row = children[-1]
        rows = children
        color = colors[children[0]]
        lines.append(((start_row, end_row, level), rows, color))
        for c in tree["children"]:
            compute_lines(c, level + 1)

    compute_lines(tree)

    return {"lines": lines, "rows": rows}


def draw_stem(axes, layout, indent=0.1):
    row_max = len(layout["rows"]) - 1
    # compute graph elements
    lines = []
    end_points = []
    corner_points = []
    for (start_row, end_row, level), rows, color in layout["lines"]:
        # NOTE: the axes grows from bottom to top, so reverse it.
        p0 = ((level + 0.5) * indent, row_max - start_row - 0.5)
        p1 = ((level + 0.5) * indent, row_max - end_row)
        end_points.append([p0, color])
        corner_points.append([p1, color])
        lines.append([p0[0], p0[1], p1[0], p1[1], color])
        for row in rows:
            p0 = ((level + 0.5) * indent, row_max - row)
            p1 = ((level + 1) * indent, row_max - row)
            lines.append([p0[0], p0[1], p1[0], p1[1], color])
            end_points.append([p1, color])
    # draw graph elements
    for l in lines:
        draw_line(
            axes,
            l[0],
            l[1],
            l[2],
            l[3],
            style={"stroke-width": 2},
            color=l[4])
    draw_points(axes, end_points, size=4, marker="o")
    draw_points(axes, corner_points, size=1, marker="o")


def draw_nodes(axes, layout, indent=0.1):
    rows = layout["rows"]
    ids = sorted(rows.keys())
    level = [rows[k][0] for k in ids]
    # NOTE: the axes grows from bottom to top, so reverse it.
    space = [x * indent for x in level][::-1]
    block = [1 - x for x in space]
    series = numpy.column_stack([space, block])
    axes.x.domain.max = 1
    axes.bars(series, along="y")


def compute_color_index(data):
    uuid = UniqueId()

    def assign_color(tree):
        if not tree:
            return
        if not tree.get("children", []):
            return
        color = uuid.id()
        for c in tree["children"]:
            c["color"] = color
        for c in tree["children"]:
            assign_color(c)

    tree = build_tree(data)
    tree["color"] = uuid.id()
    assign_color(tree)

    colors = {}

    def get_colors(tree):
        if not tree:
            return
        colors[tree["id"]] = tree["color"]
        for c in tree["children"]:
            get_colors(c)

    get_colors(tree)
    return [colors[n] for n in data["id"]]


def compute_color(colormap, tree):
    color_index = compute_color_index(tree)
    return [colormap.color(i) for i in color_index]


def draw_tree(axes, data, colors, indent=0.05, theme="dark"):
    assert theme in ("light", "dark")
    data_1 = [x * indent for x in data["level"]][::-1]
    data_2 = [1 - x for x in data_1]
    series = numpy.column_stack([data_1, data_2])
    data_2_color = colors[::-1]
    data_1_color = []
    for c in data_2_color:
        color = toyplot.color.rgba(c["r"], c["g"], c["b"], 0.1)
        data_1_color.append(color)
    if theme != "dark":
        data_2_color = data_1_color
    axes.bars(
        series, along="y", color=numpy.array([data_1_color, data_2_color]).T)
    axes.x.domain.max = 1
    text_color = "white" if theme == "dark" else "black"
    for i, n in enumerate(data["name"][::-1]):
        axes.text(
            data_1[i],
            i,
            n,
            color=text_color,
            style={"text-anchor": "start",
                   "-toyplot-anchor-shift": "5px"})

    layout = compute_layout(data, colors)
    draw_stem(axes, layout, indent)


def draw_percent(axes, data, masks, colors, data_format=".1f"):
    if masks is not None:
        data = data.where(masks)
    data = data[::-1]
    axes.bars(data, along="y", color=colors[::-1])
    axes.x.domain.min = 0
    for i, n in enumerate(data):
        format_spec = "{:%s}%%" % data_format
        axes.text(
            n,
            i,
            format_spec.format(n * 100),
            color="black",
            style={"text-anchor": "start",
                   "-toyplot-anchor-shift": "5px"})


def draw_bars(axes, data, colors):
    data = data[::-1]
    axes.bars(data, along="y", color=colors[::-1])
    for i, n in enumerate(data):
        axes.text(
            n,
            i,
            "{:.1f}".format(n),
            color="black",
            style={"text-anchor": "start",
                   "-toyplot-anchor-shift": "5px"})


def compute_header_shape(spec, ignore_root=True):
    shape = {"hrows": 0, "hcols": 0}

    def visit(spec, curr_level=0):
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                visit(s, curr_level + 1)
        else:
            assert "type" in spec
            assert "data" in spec
            shape["hcols"] += 1
            shape["hrows"] = max(shape["hrows"], curr_level + 1)

    visit(spec)
    if ignore_root:
        shape["hrows"] -= 1
    return (shape["hrows"], shape["hcols"])


def update_colspans(spec, ignore_root=True):
    hrows, _ = compute_header_shape(spec, ignore_root)

    def update_(spec, curr_level=0):
        if "subgroups" in spec:
            next_level = curr_level + 1
            if ignore_root and curr_level == 0:
                next_level = curr_level
            for s in spec["subgroups"]:
                update_(s, next_level)
            if "colspan" not in spec:
                spec["colspan"] = sum(x["colspan"] for x in spec["subgroups"])
            if "rowspan" not in spec:
                spec["rowspan"] = 1
        else:
            if "colspan" not in spec:
                spec["colspan"] = 1
            if "rowspan" not in spec:
                spec["rowspan"] = hrows - curr_level

    update_(spec)


def create_table(canvas, spec, data, ignore_root=True):
    hrows, hcols = compute_header_shape(spec, ignore_root)
    table = canvas.table(rows=len(data), columns=hcols, trows=hrows)

    colid = {"value": 0}
    colwidths = {}

    def compute_column_widths(spec):
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                compute_column_widths(s)
        else:
            if "width" in spec:
                colwidths[colid["value"]] = spec["width"]
            colid["value"] += 1

    compute_column_widths(spec)
    for i in xrange(hcols):
        if i in colwidths:
            table.column(i).width = colwidths[i]
    return table


def draw_grid(table):
    table.header.grid.style = {"stroke": "white"}
    table.grid.hlines[...] = "single"
    table.grid.vlines[...] = "single"
    table.grid.style = {"stroke": "gainsboro", "stroke-width": 1}
    for i in xrange(table.header.rows):
        table.header.row(i).height = 30


def draw_header(table, spec, colormap, ignore_root=True):
    def draw_(spec, row_start=0, col_start=0, curr_level=0):
        if not ignore_root or curr_level > 0:
            nrows = spec["rowspan"]
            ncols = spec["colspan"]
            merged = table.header.cell(
                row_start, col_start, rowspan=nrows, colspan=ncols).merge()
            merged.data = spec["label"]
            merged.align = "center"
            merged.valign = "center"
            merged.lstyle = {"font-size": "20px",
                             "font-weight": "bold",
                             "fill": "white"}
            merged.bstyle = {"fill": "darkmagenta", "stroke": "none"}
            row_start += 1
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                draw_(s, row_start, col_start, curr_level + 1)
                col_start += s["colspan"]

    draw_(spec)


def draw_body(table, spec, data, colormap):
    colors = {"value": None}

    def draw_(spec, col_start=0):
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                draw_(s, col_start)
                col_start += s["colspan"]
        else:
            tp = spec["type"]
            if not colors["value"]:
                assert tp == "tree"
            if tp == "tree":
                assert (len(spec["data"]) == 3)
                tree_data = data[spec["data"]]
                tree_data.columns = ["id", "level", "name"]
                colors["value"] = compute_color(colormap, tree_data)
                axes = table.body.column[col_start].cartesian()
                theme = spec.get("theme", "light")
                draw_tree(axes, tree_data, colors["value"], theme=theme)
            elif tp == "percent":
                axes = table.body.column[col_start].cartesian()
                column_data = data[spec["data"]]
                data_format = spec.get("format", ".1f")
                masks_expr = spec.get("mask", None)
                masks = None
                if masks_expr:
                    masks = eval(masks_expr)
                draw_percent(axes, column_data, masks, colors["value"],
                             data_format)
            elif tp == "bars":
                axes = table.body.column[col_start].cartesian()
                column_data = data[spec["data"]]
                draw_bars(axes, column_data, colors["value"])
            else:
                raise ValueError("Unknown drawing type: '%s'" % tp)

    draw_(spec)


def draw_table(canvas, spec, data, colormap="Set1", ignore_root=True):
    spec = spec.copy()
    update_colspans(spec)
    colormap = toyplot.color.brewer.map(colormap)
    table = create_table(canvas, spec, data, ignore_root)
    draw_grid(table)
    draw_header(table, spec, colormap, ignore_root)
    draw_body(table, spec, data, colormap)


def view_data(ref_db,
              spec_file,
              sql=None,
              width=800,
              height=600,
              colormap="Set1",
              no_ignore_root=False,
              save=None):
    conn = sqlite3.connect(ref_db)
    real_sql = "SELECT * FROM result ORDER BY abs_seq"
    if sql:
        real_sql = "SELECT * FROM ({}) ORDER BY abs_seq".format(sql)
    data = pandas.read_sql_query(real_sql, conn)
    spec_text = file(spec_file).read()
    if os.path.splitext(spec_file)[-1] == ".json":
        spec_text = re.sub(r"//.*", "", spec_text)
    spec = loads(spec_text)

    canvas = toyplot.canvas.Canvas(width, height)
    draw_table(canvas, spec, data, colormap, not no_ignore_root)

    if save:
        _, ext = os.path.splitext(save)
        if ext == ".png":
            toyplot.png.render(canvas, save)
        elif ext == ".pdf":
            toyplot.pdf.render(canvas, save)
        elif ext == ".svg":
            toyplot.svg.render(canvas, save)
        else:
            raise ValueError("Unknown save file type: '%s'" % ext)

    toyplot.browser.show(canvas, spec["label"])


def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("ref_db", help="Database containing analyser results")
    parser.add_argument(
        "spec_file", help="Json file specifying the visualization")
    parser.add_argument(
        "--sql", default=None, help="Sql query to extract a subset of data")
    parser.add_argument(
        "--width", default=800, type=int, help="Canvas width, in px")
    parser.add_argument(
        "--height", default=600, type=int, help="Canvas height, in px")
    parser.add_argument(
        "--colormap",
        default="Set1",
        help="Color Brewer colormap to use (default: Set1)")
    parser.add_argument(
        "--no-ignore-root",
        action="store_true",
        help="Draw root label on the canvas")
    parser.add_argument("--save", default=None, help="Save canvas to file")

    args = parser.parse_args()
    view_data(**vars(args))


if __name__ == "__main__":
    main()
