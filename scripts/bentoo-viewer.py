#!/usr/bin/env python2.7
# -*- coding: utf-8 -*-
#
'''
bentoo-viewer.py - view bentoo-calltree-analyser results graphically

This tool visualizes datasets generated by bentoo-calltree-analyser.
'''

import os
import sqlite3
import argparse
import numpy
import pandas
import json
import re
import toyplot
import toyplot.color
import toyplot.svg
import toyplot.pdf
import toyplot.png
import toyplot.browser


class UniqueId(object):
    def __init__(self, start=0):
        self.value = start

    def id(self):
        self.value += 1
        return self.value - 1


def compute_color_index(tree):
    def flat_to_recursive(nodes):
        if not nodes:
            return []
        result = []
        min_level = min(x[0] for x in nodes)
        assert (nodes[0][0] == min_level)
        nid, children = (nodes[0][1], [])
        for l, n in nodes[1:]:
            if l == min_level:
                result.append({"id": nid,
                               "children": flat_to_recursive(children)})
                nid, children = (n, [])
            else:
                children.append((l, n))
        result.append({"id": nid, "children": flat_to_recursive(children)})
        return result

    nodes = [(tree["level"][i], tree["id"][i])
             for i in xrange(len(tree["id"]))]
    d = flat_to_recursive(nodes)
    assert (len(d) == 1)

    uuid = UniqueId()

    def assign_color(tree):
        if not tree:
            return
        if not tree.get("children", []):
            return
        color = uuid.id()
        for c in tree["children"]:
            c["color"] = color
        for c in tree["children"]:
            assign_color(c)

    d[0]["color"] = uuid.id()
    assign_color(d[0])

    colors = {}

    def get_colors(tree):
        if not tree:
            return
        colors[tree["id"]] = tree["color"]
        for c in tree["children"]:
            get_colors(c)

    get_colors(d[0])
    return [colors[n] for n in tree["id"]]


def compute_color(colormap, tree):
    color_index = compute_color_index(tree)
    return [colormap.color(i) for i in color_index]


def draw_tree(axes, data, colors, indent=0.05):
    data_1 = [x * indent for x in data["level"]][::-1]
    data_2 = [1 - x for x in data_1]
    series = numpy.column_stack([data_1, data_2])
    data_2_color = colors[::-1]
    data_1_color = []
    for c in data_2_color:
        color = toyplot.color.rgba(c["r"], c["g"], c["b"], 0.1)
        data_1_color.append(color)
    axes.bars(series,
              along="y",
              color=numpy.array([data_1_color, data_2_color]).T)
    axes.x.domain.max = 1
    for i, n in enumerate(data["name"][::-1]):
        axes.text(data_1[i],
                  i,
                  n,
                  color="white",
                  style={"text-anchor": "start",
                         "-toyplot-anchor-shift": "5px"})


def draw_percent(axes, data, colors):
    data = data[::-1]
    axes.bars(data, along="y", color=colors[::-1])
    for i, n in enumerate(data):
        axes.text(n,
                  i,
                  "{:.1f}%".format(n * 100),
                  color="black",
                  style={"text-anchor": "start",
                         "-toyplot-anchor-shift": "5px"})


def draw_bars(axes, data, colors):
    data = data[::-1]
    axes.bars(data, along="y", color=colors[::-1])
    for i, n in enumerate(data):
        axes.text(n,
                  i,
                  "{:.1f}".format(n),
                  color="black",
                  style={"text-anchor": "start",
                         "-toyplot-anchor-shift": "5px"})


def compute_header_shape(spec, ignore_root=True):
    shape = {"hrows": 0, "hcols": 0}

    def visit(spec, curr_level=0):
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                visit(s, curr_level + 1)
        else:
            assert "type" in spec
            assert "data" in spec
            shape["hcols"] += 1
            shape["hrows"] = max(shape["hrows"], curr_level + 1)

    visit(spec)
    if ignore_root:
        shape["hrows"] -= 1
    return (shape["hrows"], shape["hcols"])


def update_colspans(spec, ignore_root=True):
    hrows, _ = compute_header_shape(spec, ignore_root)

    def update_(spec, curr_level=0):
        if "subgroups" in spec:
            next_level = curr_level + 1
            if ignore_root and curr_level == 0:
                next_level = curr_level
            for s in spec["subgroups"]:
                update_(s, next_level)
            if "colspan" not in spec:
                spec["colspan"] = sum(x["colspan"] for x in spec["subgroups"])
            if "rowspan" not in spec:
                spec["rowspan"] = 1
        else:
            if "colspan" not in spec:
                spec["colspan"] = 1
            if "rowspan" not in spec:
                spec["rowspan"] = hrows - curr_level

    update_(spec)


def create_table(canvas, spec, data, ignore_root=True):
    hrows, hcols = compute_header_shape(spec, ignore_root)
    table = canvas.table(rows=len(data), columns=hcols, hrows=hrows)
    return table


def draw_grid(table):
    table.header.grid.style = {"stroke": "white"}
    table.grid.hlines[...] = "single"
    table.grid.vlines[...] = "single"
    table.grid.style = {"stroke": "gainsboro", "stroke-width": 1}
    for i in xrange(table.header.rows):
        table.header.row(i).height = 30


def draw_header(table, spec, colormap, ignore_root=True):
    def draw_(spec, row_start=0, col_start=0, curr_level=0):
        if not ignore_root or curr_level > 0:
            nrows = spec["rowspan"]
            ncols = spec["colspan"]
            merged = table.header.cell(row_start,
                                       col_start,
                                       rowspan=nrows,
                                       colspan=ncols).merge()
            merged.data = spec["label"]
            merged.align = "center"
            merged.valign = "center"
            merged.style = {"font-size": "20px",
                            "font-weight": "bold",
                            "fill": "white"}
            merged.bstyle = {"fill": "darkmagenta", "stroke": "none"}
            row_start += 1
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                draw_(s, row_start, col_start, curr_level + 1)
                col_start += s["colspan"]

    draw_(spec)


def draw_body(table, spec, data, colormap):
    colors = {"value": None}

    def draw_(spec, col_start=0):
        if "subgroups" in spec:
            for s in spec["subgroups"]:
                draw_(s, col_start)
                col_start += s["colspan"]
        else:
            tp = spec["type"]
            if not colors["value"]:
                assert tp == "tree"
            if tp == "tree":
                assert (len(spec["data"]) == 3)
                tree_data = data[spec["data"]]
                tree_data.columns = ["id", "level", "name"]
                colors["value"] = compute_color(colormap, tree_data)
                axes = table.body.column(col_start).merge().axes(
                    cell_padding=2)
                draw_tree(axes, tree_data, colors["value"])
            elif tp == "percent":
                axes = table.body.column(col_start).merge().axes(
                    cell_padding=2)
                column_data = data[spec["data"]]
                draw_percent(axes, column_data, colors["value"])
            elif tp == "bars":
                axes = table.body.column(col_start).merge().axes(
                    cell_padding=2)
                column_data = data[spec["data"]]
                draw_bars(axes, column_data, colors["value"])
            else:
                raise ValueError("Unknown drawing type: '%s'" % tp)

    draw_(spec)


def draw_table(canvas, spec, data, colormap="Set1", ignore_root=True):
    spec = spec.copy()
    update_colspans(spec)
    colormap = toyplot.color.brewer.map(colormap)
    table = create_table(canvas, spec, data, ignore_root)
    draw_grid(table)
    draw_header(table, spec, colormap, ignore_root)
    draw_body(table, spec, data, colormap)


def view_data(ref_db,
              spec_file,
              sql=None,
              width=800,
              height=600,
              colormap="Set1",
              no_ignore_root=False,
              save=None):
    conn = sqlite3.connect(ref_db)
    real_sql = "SELECT * FROM result ORDER BY abs_seq"
    if sql:
        real_sql = "SELECT * FROM ({}) ORDER BY abs_seq".format(sql)
    data = pandas.read_sql_query(real_sql, conn)
    spec_text = file(spec_file).read()
    spec_text = re.sub(r"//.*", "", spec_text)
    spec = json.loads(spec_text)

    canvas = toyplot.canvas.Canvas(width, height)
    draw_table(canvas, spec, data, colormap, not no_ignore_root)

    if save:
        _, ext = os.path.splitext(save)
        if ext == ".png":
            toyplot.png.render(canvas, save)
        elif ext == ".pdf":
            toyplot.pdf.render(canvas, save)
        elif ext == ".svg":
            toyplot.svg.render(canvas, save)
        else:
            raise ValueError("Unknown save file type: '%s'" % ext)

    toyplot.browser.show(canvas, spec["label"])


def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    parser.add_argument("ref_db", help="Database containing analyser results")
    parser.add_argument("spec_file",
                        help="Json file specifying the visualization")
    parser.add_argument("--sql",
                        default=None,
                        help="Sql query to extract a subset of data")
    parser.add_argument("--width",
                        default=800,
                        type=int,
                        help="Canvas width, in px")
    parser.add_argument("--height",
                        default=600,
                        type=int,
                        help="Canvas height, in px")
    parser.add_argument("--colormap",
                        default="Set1",
                        help="Color Brewer colormap to use (default: Set1)")
    parser.add_argument("--no-ignore-root",
                        action="store_true",
                        help="Draw root label on the canvas")
    parser.add_argument("--save", default=None, help="Save canvas to file")

    args = parser.parse_args()
    view_data(**vars(args))


if __name__ == "__main__":
    main()
