#!/usr/bin/env python2.7
#
'''Analyser - Test project result analyser

Analyser provides command line interface to extract and display test result
data collected by Collector. It provided options to filter result, to choose
display table fields and to pivot resultant table. It provides a simple and
intuitive syntax.

To use the analyser, one invokes analyser.py with -m for matcher/filter, -f for
fields selection and -p for pivoting. For example, one can display how all
timers of algorithms scales w.r.t. number of nodes when using 1 threads per
process using the following command line:
    ./analyser.py result.sqlite -m nthreads=1 -m timer_name~algs::Numerical*,
    algs::Copy* -f timer_name,nnodes,max,summed -p timer_name,nnodes

Analyser tries to provide a simple CLI interface of pandas for simple use
cases, namely tasks need to be done quick and often in command line. More
sphosticated analysis need to be done directly in python using pandas etc.
'''

import os
import sys
import argparse
import re
import fnmatch
import sqlite3
import pandas


class SqliteReader:

    def read_frame(self, fn):
        conn = sqlite3.connect(fn)
        return pandas.io.sql.read_sql("SELECT * FROM result", conn)


class ExcelReader:

    def read_frame(self, fn):
        return pandas.read_excel(fn, index=False)


def make_equal_match_func(value):
    if isinstance(value, list):

        def match(x):
            return str(x) in value

        return match
    else:

        def match(x):
            return x == type(x)(value)

        return match


def make_glob_match_func(value):
    if isinstance(value, list):

        def match(x):
            for v in value:
                if fnmatch.fnmatch(str(x), v):
                    return True
            return False

        return match
    else:

        def match(x):
            return fnmatch.fnmatch(str(x), value)

        return match


class Matcher:

    def __init__(self, spec):
        '''Create pandas DataFrame filter from spec

        'spec' is a list of matchers, each matcher defines a rule for a single
        column match. Currently supported matchers are:
        1. name=value: dataframe[name] == value
        2. name=value,value,...: dataframe[name].isin([value, value, ...])
        3. name~value: fnmatch.fnmatch(dataframe[name], value)
        4. name~value,value,...: fnmatch any value
        '''
        compiled_matcher = []
        for item in spec:
            m = re.match(r'^(\w+)\s*([=~])\s*(.*)$', item)
            assert m is not None
            name, op, value = m.groups()
            if "," in value:
                value = [x.strip() for x in value.split(",")]
            else:
                value = value.strip()
            if op == "~":
                matcher = make_glob_match_func(value)
            else:
                matcher = make_equal_match_func(value)
            compiled_matcher.append((name, matcher))
        self.compiled_matcher = compiled_matcher

    def filter(self, frame):
        df = frame
        for name, matcher in self.compiled_matcher:
            df = df[df[name].map(matcher)]
        return df


def make_reader(reader):
    if reader == "sqlite":
        return SqliteReader()
    elif reader == "excel":
        return ExcelReader()
    else:
        raise RuntimeError("Unknown reader '%s'" % reader)


def main():
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument("data_file", help="Data file generated by Collector")
    parser.add_argument("-f",
                        "--field",
                        action='append',
                        default=[],
                        help="Field to display, value or list of values")
    parser.add_argument("-m",
                        "--match",
                        "--filter",
                        action='append',
                        default=[],
                        help="Data record matcher, name[~=]value")
    parser.add_argument("-p",
                        "--pivot",
                        help="Pivoting fields, 2 or 3 element list")
    parser.add_argument("-s", "--save", help="Save result to a CSV file")
    parser.add_argument("--reader", choices=["sqlite", "excel"],
                        default="sqlite",
                        help="Choose database reader (default: sqlite)")

    args = parser.parse_args()
    reader = make_reader(args.reader)
    data = reader.read_frame(args.data_file)
    matcher = Matcher(args.match)
    df = matcher.filter(data)
    if args.field:
        fields = []
        for f in args.field:
            fields.extend(x.strip() for x in f.split(","))
        v = df[fields]
    else:
        v = df
    if args.pivot:
        fields = [x.strip() for x in args.pivot.split(",")]
        v = v.pivot(*fields)
    print v.to_string()
    if args.save:
        v.to_csv(args.save, index=False)


if __name__ == "__main__":
    main()
